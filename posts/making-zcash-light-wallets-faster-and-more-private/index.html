<!doctype html><html lang=en><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=author content="Liste - https://zecsec.com/"><title>Making Zcash Light Wallets Faster and More Private | ZecSec: Zcash Ecosystem Security</title><meta name=description content="Zcash Ecosystem Security Support"><meta property="og:title" content="Making Zcash Light Wallets Faster and More Private"><meta property="og:description" content="In this post, I&rsquo;m going to sketch changes to the Zcash protocol that would allow light wallets to be both much faster and more private than they currently are. By writing this post, I hope to start a discussion about how we can pragmatically fix the privacy leaks in the current light wallet protocol and at the same time vastly improve light wallet performance.
Warning: There are almost certainly security bugs in the protocol described below that I haven&rsquo;t caught, so please don&rsquo;t implement this without careful thought!"><meta property="og:type" content="article"><meta property="og:url" content="https://zecsec.com/posts/making-zcash-light-wallets-faster-and-more-private/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-03-02T01:00:00-07:00"><meta property="article:modified_time" content="2023-03-02T01:00:00-07:00"><meta itemprop=name content="Making Zcash Light Wallets Faster and More Private"><meta itemprop=description content="In this post, I&rsquo;m going to sketch changes to the Zcash protocol that would allow light wallets to be both much faster and more private than they currently are. By writing this post, I hope to start a discussion about how we can pragmatically fix the privacy leaks in the current light wallet protocol and at the same time vastly improve light wallet performance.
Warning: There are almost certainly security bugs in the protocol described below that I haven&rsquo;t caught, so please don&rsquo;t implement this without careful thought!"><meta itemprop=datePublished content="2023-03-02T01:00:00-07:00"><meta itemprop=dateModified content="2023-03-02T01:00:00-07:00"><meta itemprop=wordCount content="4123"><meta itemprop=keywords content><link rel=canonical href=https://zecsec.com/posts/making-zcash-light-wallets-faster-and-more-private/><link rel="shortcut icon" type=image/png href=/favicon-32.png><link rel="shortcut icon" sizes=32x32 href=/favicon-32.png><link rel=dns-prefetch href=https://www.google-analytics.com><link href=https://www.google-analytics.com rel=preconnect crossorigin><link rel=alternate type=application/atom+xml title="ZecSec: Zcash Ecosystem Security" href=https://zecsec.com//atom.xml><link rel=alternate type=application/json title="ZecSec: Zcash Ecosystem Security" href=https://zecsec.com//feed.json><link rel="shortcut icon" type=image/png href="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR42mNk+A8AAQUBAScY42YAAAAASUVORK5CYII="><style>*,:after,:before{box-sizing:border-box;padding:0}body{font:1rem/1.5 '-apple-system',BlinkMacSystemFont,avenir next,avenir,helvetica,helvetica neue,ubuntu,roboto,noto,segoe ui,arial,sans-serif;text-rendering:optimizeLegibility;-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale;padding:2rem;background:#f5f5f5;color:#000}.skip-link{position:absolute;top:-40px;left:0;background:#eee;z-index:100}.skip-link:focus{top:0}h1,h2,h3,h4,h5,strong,b{font-size:inherit;font-weight:600}h2{font-size:1.5em}h3{font-size:1.2em;color:#454545}header{line-height:2;padding-bottom:1.5rem}.link{overflow:hidden;text-overflow:ellipsis;white-space:nowrap;overflow:hidden;text-overflow:ellipsis;text-decoration:none}.time{font-variant-numeric:tabular-nums;white-space:nowrap}blockquote{border-left:5px solid #eee;padding-left:1rem;margin:0}a,a:visited{color:inherit}a:hover,a.heading-link{text-decoration:none}pre{padding:.5rem;overflow:auto;overflow-x:scroll;overflow-wrap:normal}code,pre{font-family:San Francisco Mono,Monaco,consolas,lucida console,dejavu sans mono,bitstream vera sans mono,monospace;font-size:normal;font-size:small;background:#eee}code{margin:.1rem;border:none}ul{list-style-type:square}ul,ol{padding-left:1.2rem}.list{line-height:2;list-style-type:none;padding-left:0}.list li{padding-bottom:.1rem}.meta{color:#777}.content{max-width:70ch;margin:0 auto}header{line-height:2;display:flex;justify-content:space-between;padding-bottom:1rem}header a{text-decoration:none}header ul{list-style-type:none;padding:0}header li,header a{display:inline}h2.post{padding-top:.5rem}header ul a:first-child{padding-left:1rem}.nav{height:1px;background:#000;content:'';max-width:10%}.list li{display:flex;align-items:baseline}.list li time{flex:initial}.hr-list{margin-top:0;margin-bottom:0;margin-right:.5rem;margin-left:.5rem;height:1px;border:0;border-bottom:1px dotted #ccc;flex:1 0 1rem}.m,hr{border:0;margin:3rem 0}img{max-width:100%;height:auto}h2.post{margin-bottom:0}.post-date{margin:0% 0;color:#9a9a9a}.index-date{color:#9a9a9a}.animate-blink{animation:opacity 50s infinite;opacity:1;display:none}@keyframes opacity{0%{opacity:1}50%{opacity:.5}100%{opacity:0}}.tags{display:flex;justify-content:space-between}.tags ul{padding:0;margin:0}.tags li{display:inline}.avatar{height:120px;width:120px;position:relative;margin:-10px 0 0 15px;float:right;border-radius:50%}.table{width:100%;margin-bottom:1rem;color:#111}.table-bordered{border:1px solid #dee2e6}table{border-collapse:collapse}.table-bordered thead th,.table-bordered thead td{border-bottom-width:2px}.table thead th{vertical-align:bottom;border-bottom:2px solid #dee2e6;border-bottom-width:2px}.table-bordered th,.table-bordered td{border:1px solid #dee2e6;border-bottom-color:#dee2e6;border-bottom-style:solid;border-bottom-width:1px}.table th,.table td{padding:.75rem;vertical-align:top;border-top:1px solid #dee2e6}th{text-align:inherit}.table-bordered th,.table-bordered td{border:1px solid #dee2e6}.table th,.table td{padding:.75rem;vertical-align:top;border-top:1px solid #dee2e6}.table{width:100%;margin-bottom:1rem;color:#111}.table th,.table td{padding:.75rem;vertical-align:top;border-top:1px solid #dee2e6}.table thead th{vertical-align:bottom;border-bottom:2px solid #dee2e6}.table tbody+tbody{border-top:2px solid #dee2e6}.table-sm th,.table-sm td{padding:.3rem}.table-bordered{border:1px solid #dee2e6}.table-bordered th,.table-bordered td{border:1px solid #dee2e6}.table-bordered thead th,.table-bordered thead td{border-bottom-width:2px}.table-borderless th,.table-borderless td,.table-borderless thead th,.table-borderless tbody+tbody{border:0}.table-striped tbody tr:nth-of-type(odd){background-color:rgba(0,0,0,5%)}.table-hover tbody tr:hover{color:#111;background-color:rgba(0,0,0,.075)}.table-primary,.table-primary>th,.table-primary>td{background-color:#b8daff}.table-primary th,.table-primary td,.table-primary thead th,.table-primary tbody+tbody{border-color:#7abaff}.table-hover .table-primary:hover{background-color:#9fcdff}.table-hover .table-primary:hover>td,.table-hover .table-primary:hover>th{background-color:#9fcdff}.table-secondary,.table-secondary>th,.table-secondary>td{background-color:#d6d8db}.table-secondary th,.table-secondary td,.table-secondary thead th,.table-secondary tbody+tbody{border-color:#b3b7bb}.table-hover .table-secondary:hover{background-color:#c8cbcf}.table-hover .table-secondary:hover>td,.table-hover .table-secondary:hover>th{background-color:#c8cbcf}.table-success,.table-success>th,.table-success>td{background-color:#c3e6cb}.table-success th,.table-success td,.table-success thead th,.table-success tbody+tbody{border-color:#8fd19e}.table-hover .table-success:hover{background-color:#b1dfbb}.table-hover .table-success:hover>td,.table-hover .table-success:hover>th{background-color:#b1dfbb}.table-info,.table-info>th,.table-info>td{background-color:#bee5eb}.table-info th,.table-info td,.table-info thead th,.table-info tbody+tbody{border-color:#86cfda}.table-hover .table-info:hover{background-color:#abdde5}.table-hover .table-info:hover>td,.table-hover .table-info:hover>th{background-color:#abdde5}.table-warning,.table-warning>th,.table-warning>td{background-color:#ffeeba}.table-warning th,.table-warning td,.table-warning thead th,.table-warning tbody+tbody{border-color:#ffdf7e}.table-hover .table-warning:hover{background-color:#ffe8a1}.table-hover .table-warning:hover>td,.table-hover .table-warning:hover>th{background-color:#ffe8a1}.table-danger,.table-danger>th,.table-danger>td{background-color:#f5c6cb}.table-danger th,.table-danger td,.table-danger thead th,.table-danger tbody+tbody{border-color:#ed969e}.table-hover .table-danger:hover{background-color:#f1b0b7}.table-hover .table-danger:hover>td,.table-hover .table-danger:hover>th{background-color:#f1b0b7}.table-light,.table-light>th,.table-light>td{background-color:#fdfdfe}.table-light th,.table-light td,.table-light thead th,.table-light tbody+tbody{border-color:#fbfcfc}.table-hover .table-light:hover{background-color:#ececf6}.table-hover .table-light:hover>td,.table-hover .table-light:hover>th{background-color:#ececf6}.table-dark,.table-dark>th,.table-dark>td{background-color:#c6c8ca}.table-dark th,.table-dark td,.table-dark thead th,.table-dark tbody+tbody{border-color:#95999c}.table-hover .table-dark:hover{background-color:#b9bbbe}.table-hover .table-dark:hover>td,.table-hover .table-dark:hover>th{background-color:#b9bbbe}.table-active,.table-active>th,.table-active>td{background-color:rgba(0,0,0,.075)}.table-hover .table-active:hover{background-color:rgba(0,0,0,.075)}.table-hover .table-active:hover>td,.table-hover .table-active:hover>th{background-color:rgba(0,0,0,.075)}.table .thead-dark th{color:#fff;background-color:#343a40;border-color:#454d55}.table .thead-light th{color:#495057;background-color:#e9ecef;border-color:#dee2e6}.table-dark{color:#fff;background-color:#343a40}.table-dark th,.table-dark td,.table-dark thead th{border-color:#454d55}.table-dark.table-bordered{border:0}.table-dark.table-striped tbody tr:nth-of-type(odd){background-color:rgba(255,255,255,5%)}.table-dark.table-hover tbody tr:hover{color:#fff;background-color:rgba(255,255,255,.075)}@media(max-width:575.98px){.table-responsive-sm{display:block;width:100%;overflow-x:auto;-webkit-overflow-scrolling:touch}.table-responsive-sm>.table-bordered{border:0}}@media(max-width:767.98px){.table-responsive-md{display:block;width:100%;overflow-x:auto;-webkit-overflow-scrolling:touch}.table-responsive-md>.table-bordered{border:0}}@media(max-width:991.98px){.table-responsive-lg{display:block;width:100%;overflow-x:auto;-webkit-overflow-scrolling:touch}.table-responsive-lg>.table-bordered{border:0}}@media(max-width:1199.98px){.table-responsive-xl{display:block;width:100%;overflow-x:auto;-webkit-overflow-scrolling:touch}.table-responsive-xl>.table-bordered{border:0}}.table-responsive{display:block;width:100%;overflow-x:auto;-webkit-overflow-scrolling:touch}.table-responsive>.table-bordered{border:0}</style><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","articleSection":"posts","name":"Making Zcash Light Wallets Faster and More Private","headline":"Making Zcash Light Wallets Faster and More Private","alternativeHeadline":"","description":"In this post, I\u0026rsquo;m going to sketch changes to the Zcash protocol that would allow light wallets to be both much faster and more private than they currently are. By writing this post, I hope to start a discussion about how we can pragmatically fix the privacy leaks in the current light wallet protocol and at the same time vastly improve light wallet performance.\nWarning: There are almost certainly security bugs in the protocol described below that I haven\u0026rsquo;t caught, so please don\u0026rsquo;t implement this without careful thought!","inLanguage":"en-us","isFamilyFriendly":"true","mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/zecsec.com\/posts\/making-zcash-light-wallets-faster-and-more-private\/"},"author":{"@type":"Person","name":"Taylor Hornby"},"creator":{"@type":"Person","name":"Taylor Hornby"},"accountablePerson":{"@type":"Person","name":"Taylor Hornby"},"copyrightHolder":"ZecSec: Zcash Ecosystem Security","copyrightYear":"2023","dateCreated":"2023-03-02T01:00:00.00Z","datePublished":"2023-03-02T01:00:00.00Z","dateModified":"2023-03-02T01:00:00.00Z","publisher":{"@type":"Organization","name":"ZecSec: Zcash Ecosystem Security","url":"https://zecsec.com/","logo":{"@type":"ImageObject","url":"https:\/\/zecsec.com\/static\/favicon-32.png","width":"32","height":"32"}},"image":"https://zecsec.com/static/favicon-32.png","url":"https:\/\/zecsec.com\/posts\/making-zcash-light-wallets-faster-and-more-private\/","wordCount":"4123","genre":[],"keywords":[]}</script><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css integrity=sha384-vKruj+a13U8yHIkAyGgK1J3ArTLzrFGBbBc0tDp4ad/EyewESeXE/Iv67Aj8gKZ0 crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.js integrity=sha384-PwRUT/YqbnEjkZO0zZxNqcxACrXe+j766U2amXcgMg5457rve2Y7I6ZJSm2A0mS4 crossorigin=anonymous></script>
<script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/contrib/auto-render.min.js integrity=sha384-+VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4+/RRE05 crossorigin=anonymous onload=renderMathInElement(document.body)></script></head><body><a class=skip-link href=#main>Skip to main</a><main id=main><div class=content><header><p style=padding:0;margin:0><a href=/><b>ZecSec: Zcash Ecosystem Security</b>
<span class="text-stone-500 animate-blink">▮</span></a></p><ul style=padding:0;margin:0><li><a href=/posts/><span>Blog</span></a><li><a href=/overview/><span>Overview</span></a><li><a href=/posts/zecsec-roadmap-for-2023/><span>Roadmap</span></a><li><a href=/contact/><span>Contact</span></a></li></ul></header><hr class=hr-list style=padding:0;margin:0><section><h2 class=post>Making Zcash Light Wallets Faster and More Private</h2><div class=post-date><span class="g time">March 2, 2023</span> &#8729;
By Taylor Hornby</div><p>In this post, I&rsquo;m going to sketch changes to the Zcash protocol that would allow
light wallets to be both <em>much faster</em> and <em>more private</em> than they currently
are. By writing this post, I hope to start a discussion about how we can
pragmatically fix the privacy leaks in the current light wallet protocol and at
the same time vastly improve light wallet performance.</p><p><em><strong>Warning:</strong> There are almost certainly security bugs in the protocol described below that I haven&rsquo;t caught,
so please don&rsquo;t implement this without careful thought!</em></p><h2 id=two-kinds-of-wallet>Two Kinds of Wallet</h2><p>The proposed design would allow users to make a choice between two kinds of
wallet depending on their preferences for privacy versus performance.</p><h3 id=option-1-privacy-optimized-wallet>Option 1: Privacy-Optimized Wallet</h3><p>A <em>privacy-optimized wallet</em> uses trial decryption to find its notes, just like a
full node does. The wallet is careful to always download every transaction,
including all of the data it might ever need such as memo fields. As a result,
the externally-visible behavior of the wallet reveals no information about how
many transactions it is receiving. The cost, of course, is that trial-decrypting
every transaction in the blockchain is bandwidth- and compute-intensive, so
this option is best suited to wallets running on PCs and servers.</p><p>This option is for users who need extra-strong privacy guarantees, including
<em>address unlinkability privacy</em>, where even an adversary who knows a wallet&rsquo;s
address and has compromised the light wallet server cannot find out which wallet
the address belongs to. In the performance-optimized option, we will give up
this privacy property; this is likely necessary, as we will discuss later.</p><h3 id=option-2-performance-optimized-wallet>Option 2: Performance-Optimized Wallet</h3><p>In the proposed design, a <em>performance-optimized wallet</em> relies on a set of
partially-trusted <em>Mix Authority</em> servers as well as a partially-trusted
<em>Detection Server</em> to quickly detect their transactions. What these servers do
is explained later on.</p><p>A performance-optimized wallet has the following performance and privacy
properties:</p><h4 id=performance-properties>Performance Properties</h4><ul><li>The wallet must authenticate and sync the note commitment and nullifier sets.</li><li>When the wallet is launched, it has to download and trial-decrypt <em>at most
the current day&rsquo;s worth of transactions</em>.</li><li>For all days previous to the current one, the wallet can fetch its
transactions quickly from its Detection Server in a way that <em>does not require
the Detection Server to scan over all transactions for each user</em>, i.e. a single
Detection Server could reliably serve thousands or more users.</li><li>If the wallet&rsquo;s chosen Detection Server goes down, or the user switches
Detection Servers, the new Detection Server will have to perform trial-detection
(a linear scan over all new transactions) on the user&rsquo;s behalf until the user
updates their addresses.</li><li>At least one of the Mix Authorities must be operational, otherwise wallets
must find their transactions by downloading everything and using
trial-decryption.</li><li>The wallet must still update the witnesses for their unspent notes as usual.</li><li>The sizes of addresses and transactions are moderately increased.</li></ul><h4 id=privacy-properties>Privacy Properties</h4><ul><li>When implemented carefully, even global passive adversaries observing
encrypted network traffic learn nothing about when or how many transactions the
wallet receives, i.e. the traffic-analysis side-channels on the receiving side
are eliminated.</li><li>When a malicious or compromised Detection Server knows one of its users'
wallet&rsquo;s addresses, it can find out which user it is (i.e. identified by their IP address).</li><li>If the Detection Server is compromised but the Mix Authority servers are
honest and uncompromised, the attacker can learn <em>how many</em> transactions the
wallet receives each day, but not <em>which ones</em>.</li><li>If a Mix Authority is compromised but the wallet&rsquo;s Detection Server remains
honest and secure, the attacker learns nothing about which transactions belong
to which wallets.</li><li>Only if <em>both</em> a Mix Authority <em>and</em> the wallet&rsquo;s Detection Server are
compromised, the attacker learns exactly which transactions belong to the
wallet.</li></ul><p>When addresses are kept secret, the design also lets wallets granularly delegate
detection authority, i.e. only grant detection authority for certain days, which
further limits the effects of any server compromise that is detected and
corrected. Notably, when addresses are kept secret, even if the private state of
all Mix Authorities and Detection Servers leaks, the attacker can group
transactions within a day by wallet, but they still cannot tie those groups to
wallets&rsquo; identities<sup id=fnref:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup> or connect the groups from different days.</p><p>Although the performance-optimized protocol intentionally trades-off privacy and
adds a dependency on &ldquo;1-of-2&rdquo; trusted servers for the sake of performance, its
privacy properties are still much better than the reality today where the light
wallet server can learn precisely which transactions belong to which wallets,
confirm address ownership, and more<sup id=fnref:2><a href=#fn:2 class=footnote-ref role=doc-noteref>2</a></sup>.</p><p>The partially-trusted Mix Authorities can eventually be replaced by a
multi-party computation protocol or by a proper mixnet, eliminating the need to
use centralized services and increasing security (e.g. by requiring any
attackers to compromise multiple Mix Authorities rather than just one). One
possibility is to get proof-of-stake validators to do the mixing in a future
proof-of-stake protocol.</p><h2 id=protocol>Protocol</h2><p>In the suggested protocol, Zcash blocks are divided into daily &ldquo;epochs.&rdquo;
Performance-optimized wallets retain their privacy for the current epoch by
downloading and trial-decrypting all transactions within the current epoch. To
detect transactions in previous epochs, the protocol is augmented as follows.</p><p>The Zcash consensus rule maintainers (ECC and ZF) take community input to
maintain a permissioned list of Mix Authorities and the Zcash consensus rules
publish a set of Mix Authority public keys \(\{M_{i}\} \) for the Mix
Authorities that are active in the current epoch.</p><h3 id=address-generation>Address Generation</h3><p>To construct an address, the wallet first generates all of the usual components
of an address as normal, then derives secrets \(s, r, dsk\) from their viewing
key.</p><p>Then, the wallet obtains a verifiably-randomized public key from their Detection Server:</p><ol><li>The Detection Server publishes their public key \(S = [ssk]G_1 \) for all
users to see. Users check that they all see the same \(S\), e.g. using a
public forum or by having it hard-coded into their wallets.</li><li>The wallet sends \(r\) to the Detection Server.</li><li>The Detection Server computes \(G_r = GroupHash(r)\) and \(S_r =
[ssk]G_r\) and sends these values to the wallet, along with a zero-knowledge
proof that \(S_r\) was computed correctly.</li><li>The wallet verifies the zero-knowledge proof.</li></ol><p>This allows the Detection Server to use its \(ssk\) to efficiently decrypt
messages sent to any \(S_r\) generated through this process without letting
the Detection Server determine <em>which</em> particular \(S_r\) the message was
encrypted to. (This is similar to how diversified addresses work, except we
don&rsquo;t want the Detection Server to be able to know which &ldquo;diversifier&rdquo; was
used.) This is done to ensure that we never give the Detection Server unlimited
detection capabilities as long as the address is kept secret from them. Checking
the consistency of \(S\) between users ensures that the Detection Server is
not using unique private keys in order to identify users.</p><p>Next, the wallet generates two extra elements for their address:</p><ol><li>A transaction tagging key \(K_{TT} = H(s)\), where \(H\) is a
collision-resistant PRF.</li><li>A detection public key \( D = [dsk]G_2 \).</li></ol><p>Given the wallet&rsquo;s normal address \(addr \), the wallet&rsquo;s address is now
\((addr, G_r, S_r, K_{TT}, D)\).</p><p>If the wallet chooses to be privacy-optimized, i.e. to opt-out of efficient
detection, it sets \(G_r, S_r, K_{TT}, D\) all to random (but valid for their type)
values.</p><h3 id=sending-transactions>Sending Transactions</h3><p>Given a wallet&rsquo;s address \((addr, G_r, S_r, K_{TT}, D)\), a sender constructs a
transaction as follows, in addition to all of the normal steps of constructing a
transaction.</p><p>\(e\) is the current epoch number, \(Enc(pk, ptxt, ad, [G = G_3, esk
\leftarrow \$, epk = [esk]G])\) is a DH-based key-private authenticated
public key encryption algorithm with additional data which can be the same as
the one used for Orchard note encryption, and \(PRF^T, PRF^D\) are
collision-resistant PRFs.</p><ol><li>Let \(C\) be the usual note ciphertext and construct an additional note
ciphertext \(C^L\) that uses a fresh random ephemeral key<sup id=fnref:3><a href=#fn:3 class=footnote-ref role=doc-noteref>3</a></sup>.</li><li>Generate an ephemeral keypair \(esk, epk = [esk]G_r\).</li><li>Construct the transaction tag \(T = PRF^{T}(K_{TT}, G_r||e) \).</li><li>Construct a proof \(\pi\) that for public inputs \(T, epk\), the
transaction creator knows witnesses \(G_r, esk\) such that \(T\) was
calculated as above and \(epk = [esk]G_r\), i.e. \(epk\) uses the same base
as was used in the calculation of \(T\).</li><li>Construct the tag ciphertext \(C^T = Enc(S_r, T||\pi, &ldquo;tct&rdquo; || e, G_r, esk, epk)\).</li><li>Construct the epoch detection public key \(D^* = D + [PRF^D(K_{TT}, e)]G_2\).</li><li>Construct the detection ciphertext \(C^D = Enc(D^*, &ldquo;true&rdquo;, &ldquo;dct&rdquo; || e)\)</li><li>Construct the post-mix ciphertext \(C^{PoM} = (C^T, C^D, C^L)\).</li><li>Construct the pre-mix ciphertexts \(C^{PrM}_i = Enc(M_i, C^{PoM}, &ldquo;mix&rdquo; || e)\).</li></ol><p>The new note ciphertext is \( (C, \{C_i^{PrM}\}) \). All of the other
transaction components are constructed as usual.</p><h3 id=mixing-and-detection>Mixing and Detection</h3><p>At the end of each epoch, each Mix Authority \(i \) collects the list of
pre-mix ciphertexts \( \{ C_{i,j}^{PrM} \} \) for that epoch, decrypts them,
and publishes and signs the <em>sorted and deduplicated</em> list of post-mix ciphertexts. By
sorting and deduplicating the list, the Mix Authority makes it impossible for
others to tell which pre-mix ciphertexts (outputs on the blockchain)
correspond with which post-mix ciphertexts. In other words, without additional
information, each post-mix ciphertext is hiding in an epoch-sized anonymity set
of shielded outputs.</p><p>The deduplication is necessary to prevent attackers from &ldquo;tagging&rdquo; ciphertexts
through the mixing process by repeating them a unique number of times. The
\(&ldquo;mix&rdquo;||e\) additional data is necessary to prevent attackers from
replaying honestly-created pre-mix ciphertexts across epochs to circumvent the
mixing. The sorting needs to happen in constant time, otherwise the running time
of the sorting algorithm could leak information about connections between
pre-mix and post-mix ciphertexts.</p><p>As long as <em>at least one</em> Mix Authority is online, the post-mix ciphertexts will
become available. As long as <em>all</em> Mix Authorities are honest and uncompromised,
the mapping between transactions and post-mix ciphertexts will remain secret.
(These properties can be strengthened by onion-encrypting the pre-mix
ciphertexts to follow different paths through multiple levels of Mix
Authorities, as is done in a mixnet.)</p><p>Once at least one of the Mix Authorities have published the list of post-mix
ciphertexts, all of the Detection Servers obtain and authenticate the list.
Then, for each \(C^{PoM}_i = (C^T_i, C^D_i, C^L_i)\), they use their secret
key \(ssk\) to try to decrypt \(C^T_i\). If this works, they obtain \(T\)
and \(\pi\), and after checking \(\pi\), they enter \(C^{L}_i\) into their
database indexed on \(T\).</p><h3 id=receiving-transactions>Receiving Transactions</h3><p>All wallets must always download and authenticate the entire note commitment and
nullifier sets. The protocol then allows wallets to detect their incoming
transactions in three different ways.</p><h4 id=1-trial-decryption>1. Trial Decryption</h4><p>First, the wallet can use its viewing key to trial-decrypt the regular note
ciphertext \(C \) as is done currently. This remains possible even if all of
the Mix Authorities and Detection Servers go offline.</p><h4 id=2-indexed-detection>2. Indexed Detection</h4><p>Second, the fastest way for a wallet to obtain its transactions for an epoch
\(e\) is to ask its Detection Server for a random nonce \(n\) and then
prove in zero-knowledge, for public parameters \(e, n, T\), that it knows the
secrets \(s, r\) such that \(T = PRF^T(H(s), GroupHash(r)||e)\).</p><p>The Detection Server authenticates the user by checking the zero-knowledge proof
and the freshness of the nonce and then provides the wallet with all of the
\(C^L\) ciphertexts it has indexed on \(T\) using a constant-bandwidth protocol.</p><h4 id=3-non-indexed-detection>3. Non-Indexed Detection</h4><p>If the wallet&rsquo;s Detection Server has gone offline, the wallet has a third option
for efficiently retrieving its transactions from a different Detection Server.
To do this, it constructs its epoch detection secret key \(dsk + PRF^D(K_{TT},
e)\) and provides it and the epoch number \(e\) to the new Detection Server.
The Detection Server uses this key to trial-decrypt each \(C^D\) in the epoch, and
when decryption succeeds, it provides the wallet with the corresponding \(C^L\) over
a constant-bandwidth protocol.</p><p>When using indexed or non-indexed detection, the wallet obtains and decrypts the
\(C^L\) ciphertexts then authenticates their contents by re-computing the note
commitment and checking that the same commitment appears in the authenticated
note commitment set at a position within the expected epoch.</p><h3 id=security-analysis>Security Analysis</h3><h4 id=address-unlinkability>Address Unlinkability</h4><p>When a wallet&rsquo;s Detection Server knows the wallet&rsquo;s address, the detection
server can identify which of its users owns the wallet (e.g. by IP address).</p><p>This seems unavoidable when the wallet doesn&rsquo;t download everything, because with
the address known, the Detection Server can always send thousands of
transactions to the address. Assuming this doesn&rsquo;t cause <em>all</em> wallets to
download thousands of transactions worth of data, the victim wallet then either has
to make itself distinguishable from other wallets by downloading thousands of
transactions worth of data or fail to receive many of its transactions,
suggesting a DoS attack on addresses is possible. Either <em>all</em> wallets download
lots of data when
<em>any</em> wallet needs to, DoS attacks on addresses are possible, or wallets with
addresses that receive lots of transactions are identifiable by the amount of
data the Detection Server sends to them.</p><p>Only the Detection Server observes this leakage, not a global passive adversary,
because the Detection Server always sends detected transactions over a
constant-bandwidth protocol (e.g. in fixed-sized packets sent at regular
intervals).</p><p><em>Open Question:</em> Can we prove that this limitation applies to all possible
protocols?</p><h4 id=granular-delegation-of-detection-authority>Granular Delegation of Detection Authority</h4><p>When the user&rsquo;s chosen Detection Server knows their wallet&rsquo;s address, it can
perpetually find out which \(C^L\) belong to the wallet. This is because,
knowing \(G_r, K_{TT}\), it can re-compute the address&rsquo;s tags for each epoch.
This is always possible for any design that allows the Detection Server to
&ldquo;bucket&rdquo; transactions for future retrieval by wallets: the Detection Server can
send many transactions to the known address and watch which &ldquo;bucket&rdquo; grows. As
long as the Mix Authorities are secure, even a Detection Server that knows a
wallet&rsquo;s address will only learn <em>how many</em> transactions the wallet receives
each day.</p><p>When the wallet&rsquo;s address is kept secret from the Detection Server, the
Detection Server is unable to reliably detect transactions for the wallet in
epochs other than the ones explicitly requested by the wallet.</p><p>In the indexed detection case, this is because given the epoch-specific tag \(T
= PRF^T(K_{TT}, G_r||e)\), the Detection Server cannot compute the tag for
any other epoch without knowing \(K_{TT}\). For other epochs, the
Detection Server only learns, &ldquo;one of my users&rsquo; wallets received \(n\)
transactions&rdquo; but it does not know which wallet until the wallet reveals its tag
for that epoch. The anonymity set is lower-bounded by wallets using the same
Detection Server whose addresses are also secret and who have not provided their
epoch-specific tags. This is especially useful if a Detection Server is known to
be compromised and all users stop using it. Additionally, any user of the
Detection Server can increase the size of the anonymity set by registering
addresses to which they send random amounts of &ldquo;dummy&rdquo; transactions.</p><p>Since the Detection Server only ever needs ephemeral access to the tags wallets
request, the Detection Server can be careful to delete all trace of the
relationship between wallets&rsquo; identities and their requested tags after the
requests have been served. This ensures that if the Detection Server&rsquo;s state
gets leaked, it will be apparent how <em>mix-anonymized ciphertexts</em> are grouped
together within epochs, but for addresses that were kept secret, those groupings
(daily transaction counts) will not be tied to wallets&rsquo; identities in any way.
If Mix Authorities&rsquo; keys are leaked too, it will be apparent how <em>transactions</em>
are grouped daily, but those groups won&rsquo;t be linked to wallets&rsquo; identities when
addresses are kept secret.</p><p>In the non-indexed case, the Detection Server learns \(dsk + PRF^D(K_{TT},
e)\). Without knowing \(K_{TT}\), they cannot recover \(dsk\) or any of the
other per-epoch detection secret keys. This is useful in case the user&rsquo;s main
Detection Server goes down and they are forced to use a less-trustworthy one. As
long as their address is kept secret, the new Detection Server is only granted
detection authority for a limited number of epochs.</p><p>Using Identity-Based Encryption (IBE), the non-indexed case can probably be improved
so that it does not rely on address secrecy. I am currently investigating the
impact IBE would have on address sizes.</p><p>In all cases, it is impossible to link a pre-mix ciphertext to a post-mix
ciphertext unless either you can decrypt a message encrypted to a Mix
Authority&rsquo;s public key key or you created the transaction yourself. This
guarantees that even if the Detection Server learns a user&rsquo;s address, their true
notes are still hiding in an epoch-sized anonymity set. At most, they learn how
many notes the user receives in each epoch, and as explained earlier, can
identify the address owner (by IP address) when they connect and ask for their
transactions.</p><h4 id=obfuscating-the-number-of-transactions-received>Obfuscating the number of transactions received</h4><p>As long as the Mix Authorities are secure, wallets can send random amounts of
transactions to themselves to obscure the total number of transactions that they
receive. The Detection Server is unable to tell which transactions are
self-transactions, so they would see the distribution \(R + F\), where \(R\)
is the distribution of real transactions the wallet receives and \(F\) is the
distribution of fake transactions the wallet generates to itself. This would
require wallets to be online daily to send fake transactions in each epoch, or
they could delegate the task to a third-party service by providing their
address.</p><h4 id=lack-of-post-quantum-privacy>Lack of post-quantum privacy</h4><p>The suggested protocol changes are <em>not</em> post-quantum private. Large-scale
quantum computers would be able to reveal the connection between pre-mix and
post-mix ciphertexts. Additionally, quantum computers would be able to decrypt
the tags. So, even when addresses are kept secret, quantum computers would be
able to group transactions with identical tags within epochs. In other words, a
quantum attacker has the same capabilities as an attacker who had compromised
all Mix Authorities and Detection Servers. This is a <em>weakening</em> of Zcash&rsquo;s
post-quantum privacy properties, since currently Zcash is conjectured to be
post-quantum private when addresses are kept secret.</p><h4 id=the-need-for-pi-in-step-4-of-transaction-generation>The need for \(\pi\) in step 4 of transaction generation</h4><p>The Detection Server checks the proof \(\pi\) generated in step 4 and makes
sure that wallets fetching tags know \(r\) in order to prevent senders from
being able to learn which Detection Server an address uses.</p><p>Without these checks, an attacker (a) could use a <em>different</em> \(G_{r*}\) from
the same server as the encryption base while still computing the tag with
\(G_r\) and the victim would receive the transaction if and only if the
attacker used the same server, or (b) could send a transaction to themselves (a
\(K_{TT}\) for which they know \(s\)) using the victim&rsquo;s \(G_r\) for both
the encryption and \(T\); they would receive the transaction if and only if
they used the same server.</p><p>In case (a), \(\pi\) ensures that the tag \(T\) is always computed using the
same base as was used for the encryption, so if an attacker tried this, the
victim would not receive the transaction because they would never request the
attacker-generated tags that use a different base. In case (b), the attacker is
not able to look up tags constructed using the victim&rsquo;s \(G_r\) because the
Detection Server requires them to prove knowledge of \(r\) when requesting a
tag.</p><p>This kind of attack is possible in general for any protocol by DDoSing a
Detection Server and observing if that prevents the victim from receiving their
transaction. However, using a DDoS attack to carry out the attack would be much
more obvious than exploiting the weaknesses that would exist without these
checks.</p><p>With these checks in place, the protocol has better privacy properties for receivers than the
state-of-the-art mixnet design
<a href=https://github.com/zcash/zcash/issues/288#issuecomment-658348272>Loopix</a>,
which requires senders to know which Detection Server (&ldquo;providers&rdquo; in their
terminology) the recipient uses.</p><h3 id=optimizations-and-improvements>Optimizations and Improvements</h3><p>\(s\) and \(r\) can be combined by using \(G_s = GroupHash(s)\) instead of
\(G_r = GroupHash(r)\). However, to do this, the address registration process
must be modified so that the wallet only sends \(G_s\) to the server (so that
it doesn&rsquo;t disclose \(s\)), and the wallet must prove in zero knowledge that
\(G_s = GroupHash(s)\) (otherwise the registration API becomes a
decryption oracle!).</p><p>The same protocol can also be used for transaction inputs so that wallets can
detect their spends efficiently.</p><p>Identity-based encryption could also potentially be used for Detection Servers'
public keys so that their private keys can be kept offline and only loaded onto
the live server as needed, and old private keys can be deleted after they are no
longer needed. This would provide stronger forward-security and
backward-security properties in case a well-operated Detection Server is
compromised.</p><p>Since, assuming address secrecy, indexed lookups across days cannot be linked,
wallets can perform each lookup over a fresh Tor circuit to further obfuscate
the number of transactions their wallet receives over time. This would be vulnerable to
global passive adversaries and to timing correlation attacks, however.</p><p>If the additional privacy and compromise-resistance properties for the indexed
detection case that rely on address secrecy are deemed not to be very useful,
the protocol can be greatly simplified using <a href=https://github.com/zcash/zcash/issues/288#issuecomment-658348272>Daira Hopwood&rsquo;s detection key
design</a>.</p><p>The Zcash consensus rules could require wallets to pay a fee to the mix
authorities, so that they are sustainably funded.</p><p>In the proposed design, wallets only learn about the shielded outputs they
receive, and not other parts of the transaction. In order to learn the other
transaction components, e.g. to be able to compute the txid, the sender would
need to encrypt this additional data to the wallet through the mixing process,
and the wallet would need to authenticate it somehow.</p><p>Full nodes can prune all of the pre-mix ciphertexts to save on storage space.</p><p>The Mix Authority public keys should be rotated regularly to reduce the impact
of a compromise.</p><h2 id=sender-privacy>Sender Privacy</h2><p>While the above design provides pretty good privacy for transaction receivers,
it leaves open a privacy weakness for transaction senders.</p><p>Suppose, for example, that a controversial charity publishes their viewing key
for accounting purposes and that a user wishes to donate to the charity.
Alternatively, suppose that the viewing key was not published but was
compromised by an attacker.</p><p>When the user&rsquo;s wallet broadcasts their donation transaction, the attacker can
use the viewing key to try to decrypt the transaction and learn that the user is
donating to the charity.</p><p>In general, anyone who has compromised the light wallet server can find out who
is sending transactions to them or to any address whose viewing key they know.</p><p>To prevent this, we need to add sender anonymity. This could be done by re-using
the same Mix Authorities to batch and shuffle transactions before they are
broadcast publicly into the blockchain, e.g. using <a href=https://www.usenix.org/conference/usenixsecurity17/technical-sessions/presentation/piotrowska>Loopix</a>&rsquo;s Poisson mixing strategy.</p><p>Wallets can also use Loopix&rsquo;s concepts of &ldquo;loop cover&rdquo; and &ldquo;drop cover&rdquo; traffic
to respectively obscure the number of transactions received (as described above)
and eliminate information leakage about how many transactions are sent.</p><p>The &ldquo;drop cover&rdquo; traffic would never need to be added to the blockchain, and if
the same Mix Authorities are used for sending and receiving, the &ldquo;loop cover&rdquo;
traffic for obscuring receive counts need not be entered into the blockchain
either.</p><h2 id=conclusion-whats-next>Conclusion; What&rsquo;s Next?</h2><p>By implementing something like the above protocol, Zcash light wallets could
find their notes much faster while being much more private than they are today.
The drawbacks to this design are that (a) address sizes and transaction sizes
are increased, (b) the protocol relies on a permissioned set of mix authorities,
(c) daily received-transaction-count data resides on Detection Servers and is
vulnerable to being leaked, and (d) the protocol needs three additional
zero-knowledge proofs whose circuits need to be designed and implemented.
Ideally, the permissioned set of mixes would eventually be replaced by a proper
permissionless mixnet, e.g. with the mixing being done by proof-of-stake
validators.</p><p>The next steps for me are to,</p><ol><li>learn about identity-based encryption to see if it&rsquo;s reasonable to eliminate
the address secrecy requirement for granular delegation in the non-indexed detection case,</li><li>think more carefully about the protocol design to see if it can be simplified
and optimized and to ensure there aren&rsquo;t any vulnerabilities, and</li><li>collect feedback and write a ZIP.</li></ol><p>If you are a cryptographer, please try to break the protocol!</p><div class=footnotes role=doc-endnotes><hr><ol><li id=fn:1><p>Assuming the Detection Server never logs users&rsquo; IP addresses along with
the tags users look up, and that the Detection Server&rsquo;s database retains no
trace of the order in which tags are looked up.&#160;<a href=#fnref:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:2><p>See the <a href=https://zcash.readthedocs.io/en/latest/rtd_pages/wallet_threat_model.html>Zcash Wallet App Threat
Model</a>
for details about the current light wallet privacy weaknesses.&#160;<a href=#fnref:2 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:3><p>The format of \(C^L\) has to be a bit different than \(C\) because of
<a href=https://zips.z.cash/zip-0212>ZIP 212</a>; changing rseed would change rcm, which
we don&rsquo;t want, so the defenses in ZIP 212 need to be implemented differently for
\(C^L\).&#160;<a href=#fnref:3 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li></ol></div></section><div id=comments><script src=https://utteranc.es/client.js repo='issue-term="pathname"' theme='crossorigin="anonymous"' async></script></div></div></main></body></html>